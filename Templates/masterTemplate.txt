DROP TABLE IF EXISTS [config].[object_class];

CREATE TABLE [config].[object_class]
(
	[object_class_id] INT 
,	[object_class_name] SYSNAME UNIQUE
,	[object_class_view_name] SYSNAME UNIQUE
,	CONSTRAINT pk_config_object_class
	PRIMARY KEY
	(
		object_class_id
	)
);

DROP TABLE IF EXISTS [config].[object_class_property]

CREATE TABLE [config].[object_class_property]
(
	[object_class_id] INT
,	[object_class_property_id] INT
,	[object_class_system_type_id] INT
,	[object_class_property_name] SYSNAME
);

DROP TABLE IF EXISTS [config].[object_class_property_type]

CREATE TABLE [config].[system_type]
(
	[system_type_id] INT
,	[system_type_name] SYSNAME
);


DROP TABLE IF EXISTS [config].[subobject_to_object];

CREATE TABLE [config].[subobject_to_object]
(
	[subobject_class_id] INT 
,	[object_class_id] INT
,	CONSTRAINT pk_config_subObject
	PRIMARY KEY
	(
		subobject_class_id
	)
,	CONSTRAINT fk_config_sobj_to_obj_2_object_class
	FOREIGN KEY ([object_class_id])
	REFERENCES [config].[object_class]([object_class_id])
);

DROP TABLE IF EXISTS [config].[instance];

CREATE TABLE [config].[instance]
(
	[instance_id] INT
,	[instance_name] SYSNAME
);

CREATE TABLE [config].[next_id]
(
	[system_object_id] INT PRIMARY KEY
,	[next_id] INT 
,	CONSTRAINT 
		ck_next_id_positive
	CHECK
		(next_id > 0)
);


DROP TABLE IF EXISTS [instance].[database]

CREATE TABLE [instance].[database]
(
	[instance_id] INT
,	[database_id] INT
,	[database_name] SYSNAME
);

DROP TABLE IF EXISTS [database].[schema];

CREATE TABLE [database].[schema]
(
	[database_id] INT
,	[schema_id] INT
,	[schema_name] SYSNAME
);

DROP TABLE IF EXISTS [schema].[<object>];

CREATE TABLE [schema].[<object>]
(
	[schema_id] INT
,	[<object>_id] INT
,	[<object>_name] SYSNAME
,	[<objectPropertyList>]
);

DROP TABLE IF EXISTS [sub_schema].[<object>_<subobject>];

CREATE TABLE [sub_schema].[<object>_<sub_object>]
(
,	[<object>_<subobject>_id] INT
,	[<object>_<subobject>_name] SYSNAME
,	[<subobject_property_list>]
);

object :=
	table
	view
	procedure
	function
	uddt
subobject :=
	table_trigger
	table_column
	view_column
	function_parameter
	proction_parameter


comparison procedures

p_compare_database
	@database_left
	@database_right

Functional outline
1. Compare database-level properties of @database_left and @database_right
2. Compare list of schemas of @database_left and @database_right
3. Perform comparison in p_compare_schema for each pair of matching schemas

p_compare_schema
	@database_left
	@schema_left
	@database_right
	@schema_right
Functional outline
1. For each object class C, define OL(C) to be the objects in @database_left in schema @schema of class C and define OR(C) to be the objects in @database_right in schema @schema of class C.
2. For each object class C in @schema, compare the properties OL(C) to the properties
of OR(C). Let MO(C) be the pairs (p1, p2) of type C which match in name between
@database_left in schema @schema and @database_right and schema @schema.
3. For each object class C and matching object pair in MO(C) = (p1, p2), compare p1's subobjects to p2's subobjects as in p_compare_sub_schema
Note: p_compare_schema can do a wider comparison than the part of p_compare_database
which (logically) performs the actions of p_compare_schema. In particular, it can compare schemas
with different(i.e. non-matching) names 

Pseudocode
C <- list of schema-level object classes 
objects_left  <- @{n=c; e=get_objects(c, @database_left, @schema_left))} for c in C
objects_right <- @{n=c; e=get_objects(c, @database_left, @schema_left))} for c in C
 
for c in C
	only_left_c  <- objects_left[c] EXCEPT objects_right[c]
	only_right_c <- object_right[c] EXCEPT objects_left[c]
	D <- diff_table(c)
	D.insert(only_left_c)
	D.insert(only_right_c)

	match_name_c <- (c, objects_left[c].name INTERSECT objects_right[c].name)

subC <- SUBOBJECTS(C)
WHILE subC is not empty
	subC_curr <- subC.pop()
	if subC_curr IS NULL
		continue

	subc_left <- @{n=sc; e=get_objects(subC_curr, @database_left, @schema_left)}
	subc_right <- @{n=sc; }

	only_left_subc <- 

subobjects <- (SUBOBJECT(o.c)) for o in objects
	



p_compare_sub_schema
	@database_left
	@schema_left
	@database_right
	@schema_right
	@object_class
1. If @object_class IS NULL, terminate without raising an error. 
2. Define OL to be the set of objects of type @object_class in 
	@database_left and schema @schema
   Define OR to be the set of objects of type @object_class in 
	@database_right and schema @schema 
3. Compare OL and OR's properties
4. Let S = SUBCLASS(@object_class), where S is set to NULL if the class @object_class
has no subobjects. 
5. Go to step 1.) but use @object_class = S 
Note: p_compare_sub_schema does the same comparison as the part of p_compare_schema
which (logically) performs the actions of p_compare_schema. For object level comparisons,
see p_compare_object below.

p_compare_object
	@database_left
	@schema_left
	@object_name_left
	@database_right
	@schema_right
	@object_name_right
	@object_class
1. Define OL to be the object in @database_left, schema @schema_left of class @object_class
   having name = @object_name_left.
   Define OR to be the analagous object in @database_right.
2. If OL or OR are undefined, raise an error and terminate. 
3. Otherwise compare the properties of OL and OR. 
4. Let S = SUBCLASS(@object_class)
5. If S is NULL, terminate without raising an error. 
6. Define OL' to be the objects in @database_left, schema @schema_left, of
   type S which are subobjects of class S.
   Define OR' analogously for @database_right.
7. Compare the properties of OL' to the properties of OR'
8. Let S = SUBCLASS(@object_class).
9. Go to step 5. 

